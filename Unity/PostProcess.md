## shader 后处理：简单均值模糊
* **屏幕模糊效果**
	
	屏幕模糊效果是一些``高级后处理效果``的基础。比如``景深``等效果都需要``屏幕模糊``效果来实现。
	
* **模糊**
	
	所谓模糊，也就是不清楚，清晰的图片，各个像素之间会有明显的过渡，而如果各个像素之间的差距不是很大，那么图像就会模糊了。
	
	``模糊操作就是让像素间的颜色差距变小``，比如A点是红色，A点周围是绿色，模糊就像用一把刷子，将A点和周围的点的颜色混合起来，变成最终的颜色。
	
	按照不同的权值进行混合，就可以达到不同的效果。
	
	比如``均值模糊``，以及著名的``高斯模糊``。
	
	影响模糊程度的重要因素是``模糊半径``，模糊半径越大，模糊程度越大，模糊半径越小，模糊成都越小。

* **模糊半径**
	
	模糊半径即是我们采样的一个范围。
	
	```
	例如：比如模糊的半径很小，只是把像素和它周围的一圈定点混合，那么模糊的程度就很小，而如果我们加大模糊半径，极端情况是每个顶点都取了周围所有点，也就是整张图的像素平均值，那么这张图的颜色就会偏向一种颜色。
	``` 
	
* **均值模糊**
	
	简单的模糊：直接用``周围像素求和平均``，那么混合的最终图像，在某一点的权重仅仅跟模糊半径有关。
	
	效果：模糊半径越大，模糊的效果越明显。但是模糊过渡不平滑。同时也实现不了毛玻璃之类的全模糊效果。
	
* **均值模糊的改进**

	``迭代模糊``：上一次模糊的输出作为下一次模糊的输入。

		迭代次数较大时，会有一种毛玻璃的效果。但是迭代次数增加了，会耗费更多的性能。
	
	``降分辨率``
		
		减少了采样等计算操作的消耗
* **RenderTexture**
	
	渲染场景时，一般都是直接输出到帧缓存，然后输出到屏幕上。如果不想直接输出结果，而是需要对这个渲染的结果进行处理，则将渲染的结果输出到一张纹理上，也就是RenderTexture。这也是所有后处理的基础。
	
	同时可以将摄像机的输出设置到某个RT上，然后用这张RT作为一些类似镜子的物体上，就可以实现镜面效果或者屏幕效果。
	
	RenderTexture是屏幕分辨率大小的一张图片，而且是完全``不能够压缩``的。RT用的多是，内存消耗很大，在内存小的设备上，后处理叠加时很可能会由于内存耗尽而崩溃。
	
	OnRenderImage函数每帧在渲染之前都会调用，如果每一帧在这里申请RT，然后释放，不会曹成很高的GC。原因是：RenderTexture是之前申请好的一块内存区域，可以直接使用，不需要考虑GC的问题。``RenderTexture.GetTemporary和RenderTexture.ReleaseTemporary``
	
* **径向模糊效果**

	后处理：通过渲染好的屏幕图像进行全屏操作。
	
	特点：从某个像素为中心向外辐射状扩散，因此需要采样的像素和中间点像素的连线上，不同连线上的点不会相互影响。
	
	径向模糊：针对每个像素点，首先要得到一个相对于中心（不一定是屏幕中心，可以自己指定）的方向，从中心指向该像素点的方向就是径向模糊的方向，然后取当前像素点，以及沿着径向模糊方向再取几个点作为采样点，然后将这些采样点颜色的加权平均和作为该像素的颜色，采样点越靠近中心越密集，越远离中心越稀疏，最后，该像素点的输出就是这些采样点的均值。
	
	这样，在靠近中心点的位置，采样距离小，几乎为0，也就不会模糊；而越靠近边界的位置，采样的距离越大，图像也就会越模糊。
	
	* 优化
	
		```
		采样次数越高，模糊效果越好，但是采样次数高了，性能就下去了。
		移动设备上，GPU不强，但是分辨率极高，后处理这种全屏纹理采样极其耗费性能。
		高斯模糊以及Bloom效果中使用了降分辨率的操作。
		优化思路：
			1.将图像渲染到一张降低了分辨率的RT上
			2.使用这个降低了分辨率的RT进行上面的模糊处理
			3.将RT与原始图像进行差值操作。
		效果：会多一个Draw Call
		```
		
* **UNITY_UV_STARTS_AT_TOP宏**
	* 现象：
		
		开启后处理效果时屏幕上下颠倒了（或者叠加上去的部分上下颠倒了）
		
	* 原因：
		1. 使用DX渲染器时（PC平台）
		2. 开启了抗锯齿(AA)
		3. 开启了后处理并且在后处理中使用了除了MainText外的屏幕RT（或者后处理中跟屏幕像素相关的值直接传入shader）

	* 操作：增加一个后处理，把采样的uv的y坐标反过来。
		
		```
		由于DX和OpenGL之间的区别，Unity为了跨平台，为我们处理了两个图形API纹理坐标不同的问题，但是不是任何时候都为我们自动处理，当我们用后处理（写入RT）并且开启了抗锯齿的时候，就不会为我们翻转。
		如果需要自己处理这种平台差异，我们可以通过#if UNITY_UV_STARTS_AT_TOP 就可以判断是否是DX系列平台，正常的OpenGL从下到上的纹素为正，但是到DX下改成从下到上，如果主纹理uv值y方向反了，那么这个_MainText_TexelSize.y就小于0.
		```

* **高斯模糊**
	
	将原像素四周像素的颜色加权求和作为原像素的颜色以达到模糊的目的。

		



















	